#!/usr/bin/env python3
"""
BTC SPREAD EXPLOITER - THE REAL EDGE
=====================================
Ignores misleading range metrics, focuses on spread arbitrage
With 0.0001% spread, we profit from natural volatility
"""

import json
import os
import time
from collections import deque
from datetime import datetime

import ccxt
from dotenv import load_dotenv

load_dotenv()

class BTCSpreadExploiter:
    def __init__(self):
        self.exchange = None
        self.symbol = 'BTC/USDT'
        self.position_file = 'btc_spread_position.json'
        self.position = None

        # THE REAL PARAMETERS THAT MATTER
        self.trade_amount = 25.0  # Use full $25 (keep $0.56 buffer)

        # Spread-based targets (spread is 0.0001% = $11.75 on $117k)
        self.spread_multiplier = 2    # Target 2x spread minimum
        self.quick_exit = 0.00008     # 0.008% = Less than 1 tick
        self.normal_exit = 0.00015    # 0.015% = ~$17 movement
        self.good_exit = 0.0003       # 0.03% = ~$35 movement

        # Price tracking for volatility
        self.price_history = deque(maxlen=20)  # Last 20 prices
        self.last_update = 0

        # Performance
        self.trades_completed = 0
        self.winning_trades = 0
        self.total_profit = 0
        self.best_trade = 0

        self.load_position()

    def load_position(self):
        """Load saved position"""
        if os.path.exists(self.position_file):
            try:
                with open(self.position_file) as f:
                    self.position = json.load(f)
            except Exception:
                pass

    def save_position(self):
        """Save position"""
        if self.position:
            with open(self.position_file, 'w') as f:
                json.dump(self.position, f)
        elif os.path.exists(self.position_file):
            os.remove(self.position_file)

    def initialize(self):
        """Initialize Kraken Pro"""
        self.exchange = ccxt.kraken({
            'apiKey': os.getenv('KRAKEN_KEY'),
            'secret': os.getenv('KRAKEN_SECRET'),
            'enableRateLimit': True,
            'rateLimit': 200
        })
        self.exchange.load_markets()
        print("‚úÖ Connected to Kraken Pro")

    def get_market_data(self):
        """Get market data focusing on what matters"""
        ticker = self.exchange.fetch_ticker(self.symbol)

        bid = ticker['bid']
        ask = ticker['ask']
        spread_dollars = ask - bid
        spread_percent = spread_dollars / bid

        # Track price movement
        self.price_history.append(ticker['last'])

        # Calculate volatility (standard deviation of recent prices)
        if len(self.price_history) >= 5:
            avg_price = sum(self.price_history) / len(self.price_history)
            variance = sum((p - avg_price) ** 2 for p in self.price_history) / len(self.price_history)
            volatility = (variance ** 0.5) / avg_price  # As percentage

            # Recent direction
            recent_move = (self.price_history[-1] - self.price_history[-5]) / self.price_history[-5]
        else:
            volatility = 0
            recent_move = 0

        return {
            'price': ticker['last'],
            'bid': bid,
            'ask': ask,
            'spread_dollars': spread_dollars,
            'spread_percent': spread_percent,
            'volatility': volatility,
            'recent_move': recent_move,
            'volume': ticker['baseVolume']
        }

    def should_buy(self, data, usdt_balance):
        """Buy when spread is tight and volatility exists"""
        if self.position:
            return False, "In position"

        if usdt_balance < self.trade_amount:
            return False, "Insufficient funds"

        # THE KEY INSIGHT: Spread vs Volatility
        # If volatility > spread, we WILL profit

        spread = data['spread_percent']
        volatility = data['volatility']

        # GOLDEN RULE: Volatility must exceed spread
        if volatility > spread * 2:
            return True, f"Volatility {volatility:.5%} >> Spread {spread:.5%}"

        # If spread is ultra-tight, lower requirements
        if spread < 0.00015:  # Less than 0.015%
            if volatility > spread:
                return True, f"Ultra-tight spread {spread:.5%}, vol {volatility:.5%}"

        # If we haven't traded in 2 minutes and spread is good, take it
        if time.time() - self.last_update > 120 and spread < 0.0002:
            return True, f"Opportunity after wait, spread {spread:.5%}"

        return False, f"Vol {volatility:.5%} vs Spread {spread:.5%}"

    def should_sell(self, data):
        """Sell based on spread multiples"""
        if not self.position:
            return False, ""

        entry = self.position['price']
        current = data['bid']  # We receive bid when selling
        profit = (current - entry) / entry
        profit_dollars = (current - entry) * self.position['amount']

        spread_dollars = self.position.get('entry_spread', 12)  # Default $12
        spread_crossed = profit_dollars / spread_dollars  # How many spreads we've crossed

        hold_time = (time.time() - self.position['time']) / 60

        # INSTANT EXIT: Crossed 2+ spreads
        if spread_crossed >= 2:
            return True, f"{spread_crossed:.1f}x spread = ${profit_dollars:.2f}"

        # QUICK EXIT: Crossed 1+ spread
        if spread_crossed >= 1:
            return True, f"{spread_crossed:.1f}x spread = ${profit_dollars:.2f}"

        # TIME-BASED: Any profit after 2 minutes
        if hold_time > 2 and profit > 0:
            return True, f"Time exit: ${profit_dollars:.2f} @ {hold_time:.1f}min"

        # STOP LOSS: Lost 2 spreads
        if spread_crossed <= -2:
            return True, f"Stop: {spread_crossed:.1f}x spread"

        return False, f"{spread_crossed:.2f}x spread"

    def place_buy(self, data):
        """Buy BTC"""
        try:
            # Get current balance (for potential future use)
            self.exchange.fetch_balance()

            # Use ask for market buy
            price = data['ask']
            amount = (self.trade_amount * 0.998) / price
            amount = round(amount, 6)

            self.exchange.create_market_buy_order(self.symbol, amount)

            self.position = {
                'amount': amount,
                'price': price,
                'time': time.time(),
                'entry_spread': data['spread_dollars']
            }
            self.save_position()
            self.last_update = time.time()

            print(f"\nüü¢ BOUGHT {amount:.6f} BTC @ ${price:,.2f}")
            print(f"   Spread: ${data['spread_dollars']:.2f} ({data['spread_percent']:.5%})")
            print(f"   Volatility: {data['volatility']:.5%}")

            return True
        except Exception as e:
            print(f"‚ùå Buy failed: {e}")
            return False

    def place_sell(self, data):
        """Sell BTC"""
        try:
            price = data['bid']
            amount = self.position['amount']

            self.exchange.create_market_sell_order(self.symbol, amount)

            # Calculate results
            entry = self.position['price']
            profit_percent = (price - entry) / entry
            profit_dollars = amount * (price - entry)
            spreads_captured = profit_dollars / self.position.get('entry_spread', 12)
            hold_seconds = time.time() - self.position['time']

            self.trades_completed += 1
            self.total_profit += profit_dollars
            if profit_dollars > 0:
                self.winning_trades += 1
            if profit_dollars > self.best_trade:
                self.best_trade = profit_dollars

            print(f"\nüî¥ SOLD @ ${price:,.2f}")
            print(f"   Profit: ${profit_dollars:.3f} ({profit_percent:.5%})")
            print(f"   Spreads Captured: {spreads_captured:.2f}x")
            print(f"   Time: {hold_seconds:.0f} seconds")
            print(f"   Stats: {self.winning_trades}/{self.trades_completed} wins, Total: ${self.total_profit:.2f}")

            self.position = None
            self.save_position()
            self.last_update = time.time()

            return True
        except Exception as e:
            print(f"‚ùå Sell failed: {e}")
            return False

    def run(self):
        """Main loop"""
        print("=" * 70)
        print("BTC SPREAD EXPLOITER")
        print("=" * 70)
        print("Strategy: Capture 2x spread using natural volatility")
        print("Ignoring misleading range metrics")
        print("=" * 70)

        self.initialize()

        # Initial balance
        balance = self.exchange.fetch_balance()
        usdt = balance.get('USDT', {}).get('free', 0)
        btc = balance.get('BTC', {}).get('free', 0)

        data = self.get_market_data()
        starting_value = usdt + (btc * data['price'])

        print(f"üí∞ Starting: ${starting_value:.2f}")
        print(f"üìä BTC: ${data['price']:,.2f}")
        print(f"üéØ Spread: ${data['spread_dollars']:.2f} ({data['spread_percent']:.5%})")

        # Warm up price history
        print("\n‚è≥ Analyzing volatility...")
        for _ in range(5):
            data = self.get_market_data()
            time.sleep(2)

        print(f"üìà Volatility detected: {data['volatility']:.5%}")
        print("‚úÖ Ready to exploit spread!\n")

        loop = 0

        while True:
            try:
                loop += 1

                # Get fresh data
                data = self.get_market_data()
                balance = self.exchange.fetch_balance()
                usdt = balance.get('USDT', {}).get('free', 0)
                btc = balance.get('BTC', {}).get('free', 0)

                current_value = usdt + (btc * data['price'])
                pnl = current_value - starting_value

                # Display status
                if loop % 3 == 1:
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] ", end="")
                    print(f"${data['price']:,.0f} | ", end="")
                    print(f"S: {data['spread_percent']:.4%} | ", end="")
                    print(f"V: {data['volatility']:.4%} | ", end="")
                    print(f"PnL: ${pnl:+.2f}")

                # Trade logic
                if not self.position:
                    should_buy, reason = self.should_buy(data, usdt)
                    if should_buy:
                        print(f"üéØ BUY SIGNAL: {reason}")
                        self.place_buy(data)
                elif self.position:
                    should_sell, reason = self.should_sell(data)
                    if should_sell:
                        print(f"üéØ SELL SIGNAL: {reason}")
                        self.place_sell(data)
                    elif loop % 3 == 1:
                        print(f"   Holding: {reason}")

                # Fast loop for spread exploitation
                time.sleep(2)

            except KeyboardInterrupt:
                print("\n\nStopping spread exploiter...")
                break
            except Exception as e:
                print(f"Error: {e}")
                time.sleep(5)

        # Final stats
        balance = self.exchange.fetch_balance()
        usdt = balance.get('USDT', {}).get('free', 0)
        btc = balance.get('BTC', {}).get('free', 0)
        final_value = usdt + (btc * data['price'])

        print("\n" + "=" * 70)
        print("SPREAD EXPLOITATION RESULTS")
        print("=" * 70)
        print(f"Starting: ${starting_value:.2f}")
        print(f"Final: ${final_value:.2f}")
        print(f"Net PnL: ${final_value - starting_value:.2f}")
        print(f"Trades: {self.trades_completed}")
        print(f"Win Rate: {(self.winning_trades/self.trades_completed*100) if self.trades_completed > 0 else 0:.0f}%")
        print(f"Best Trade: ${self.best_trade:.2f}")
        print(f"Avg Trade: ${(self.total_profit/self.trades_completed) if self.trades_completed > 0 else 0:.2f}")

if __name__ == "__main__":
    bot = BTCSpreadExploiter()
    bot.run()
